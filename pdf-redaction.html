<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Redaction Tool - Professional PDF Tools Suite</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <style>
        :root {
            --primary: #3498db;
            --secondary: #2c3e50;
            --success: #2ecc71;
            --danger: #e74c3c;
            --warning: #f39c12;
            --light: #ecf0f1;
            --dark: #34495e;
        }
        
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body { 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: var(--dark); 
            line-height: 1.6; 
            min-height: 100vh;
            padding: 20px;
        }
        
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
        }
        
        header { 
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: var(--secondary);
            margin-bottom: 10px;
            font-size: 2.2rem;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        
        .toolbar { 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            min-width: 150px;
            text-align: center;
            font-weight: 600;
        }
        
        button:hover { 
            background: #2980b9; 
            transform: translateY(-2px);
        }
        
        button.success { background: var(--success); }
        button.success:hover { background: #27ae60; }
        
        button.danger { background: var(--danger); }
        button.danger:hover { background: #c0392b; }
        
        button.warning { background: var(--warning); }
        button.warning:hover { background: #e67e22; }
        
        button:disabled { 
            background: #bdc3c7; 
            cursor: not-allowed;
            transform: none;
        }
        
        .pdf-viewer { 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
            min-height: 600px; 
            position: relative;
            margin-bottom: 20px;
        }
        
        .canvas-container { 
            position: relative; 
            margin: 0 auto;
            border: 1px solid #ddd;
            background: white;
        }
        
        .canvas-container canvas { 
            max-width: 100%; 
            height: auto; 
            display: block; 
            margin: 0 auto;
        }
        
        .whiteout-area, .text-element { 
            position: absolute; 
            background: rgba(255, 255, 255, 0.8); 
            border: 2px dashed #e74c3c; 
            cursor: move; 
            z-index: 10;
            pointer-events: auto;
        }
        
        .whiteout-area.selected {
            border: 2px solid #3498db;
            background: rgba(52, 152, 219, 0.2);
        }
        
        .text-element { 
            padding: 5px;
            background: rgba(46, 204, 113, 0.1);
            border: 2px solid #2ecc71;
        }
        
        .text-element.selected {
            border: 2px solid #3498db;
            background: rgba(52, 152, 219, 0.2);
        }
        
        .text-element div { 
            background: white; 
            padding: 8px 12px; 
            border: 1px solid #2ecc71; 
            border-radius: 4px; 
            font-weight: bold;
            color: #2c3e50;
        }
        
        .loading { 
            display: none; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: rgba(255,255,255,0.95); 
            padding: 20px 30px; 
            border-radius: 8px; 
            font-size: 18px; 
            font-weight: 600;
            color: var(--dark);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 100;
        }
        
        #page-nav { 
            margin-top: 20px; 
            text-align: center; 
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        #page-nav button { 
            padding: 10px 20px; 
            font-size: 14px; 
            margin: 0 10px;
            min-width: 120px;
        }
        
        .status-bar {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid var(--primary);
            font-weight: 500;
        }
        
        .mode-indicator {
            display: inline-block;
            padding: 8px 15px;
            background: var(--warning);
            color: white;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            margin-left: 10px;
        }
        
        .back-to-dashboard {
            display: inline-block;
            margin-bottom: 20px;
            padding: 10px 20px;
            background: var(--secondary);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .back-to-dashboard:hover {
            background: #2c3e50;
            transform: translateY(-2px);
        }
        
        @media (max-width: 768px) {
            .toolbar { 
                flex-direction: column; 
                align-items: center; 
            }
            
            button { 
                width: 100%; 
                max-width: 300px; 
                margin: 5px 0; 
            }
            
            .pdf-viewer {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="dashboard.html" class="back-to-dashboard">‚Üê Back to Dashboard</a>
        
        <header>
            <h1>üîí PDF Redaction Tool</h1>
            <p class="subtitle">Securely redact sensitive information from your PDF documents</p>
        </header>

        <div class="status-bar" id="statusBar">
            üìù <strong>Ready:</strong> Load a PDF to start redacting sensitive information
            <span class="mode-indicator" id="modeIndicator" style="display: none;"></span>
        </div>

        <div class="toolbar">
            <input type="file" id="pdf-input" accept=".pdf" style="display: none;">
            <button id="load-pdf">üìÅ Load PDF</button>
            <button id="download-pdf" class="success" disabled>üíæ Download Redacted PDF</button>
            <button id="add-whiteout" class="warning" disabled>‚¨ú Add Redaction Box</button>
            <button id="add-text" class="success" disabled>üìù Add Custom Text</button>
            <button id="undo" disabled>‚Ü∂ Undo</button>
            <button id="redo" disabled>‚Ü∑ Redo</button>
            <button id="clear" class="danger" disabled>üóëÔ∏è Clear All</button>
        </div>

        <div class="pdf-viewer">
            <div class="loading" id="loading">
                <div>üîÑ Processing PDF...</div>
                <div style="font-size: 14px; margin-top: 10px; color: #7f8c8d;">Please wait</div>
            </div>
            <div id="pdf-container"></div>
            <div id="page-nav">
                <button id="prev-page" disabled>‚¨Ö Previous</button>
                <span style="font-weight: 600; color: var(--dark);">Page <span id="page-num">1</span> of <span id="page-count">0</span></span>
                <button id="next-page" disabled>Next ‚û°</button>
            </div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        let pdfDoc = null, pageNum = 1, scale = 1.5, canvas, ctx;
        let whiteouts = [], texts = [], selected = null, isDragging = false, startX, startY, currentX, currentY;
        let dragOffsetX = 0, dragOffsetY = 0, isAddingWhiteout = false, isAddingText = false;
        let history = [], historyIndex = -1;
        let canvasWidth = 0, canvasHeight = 0;

        const elements = {
            pdfInput: document.getElementById('pdf-input'),
            loadPdf: document.getElementById('load-pdf'),
            downloadPdf: document.getElementById('download-pdf'),
            addWhiteout: document.getElementById('add-whiteout'),
            addText: document.getElementById('add-text'),
            undo: document.getElementById('undo'),
            redo: document.getElementById('redo'),
            clear: document.getElementById('clear'),
            pdfContainer: document.getElementById('pdf-container'),
            loading: document.getElementById('loading'),
            pageNum: document.getElementById('page-num'),
            pageCount: document.getElementById('page-count'),
            prevPage: document.getElementById('prev-page'),
            nextPage: document.getElementById('next-page'),
            statusBar: document.getElementById('statusBar'),
            modeIndicator: document.getElementById('modeIndicator')
        };

        // Event Listeners
        elements.loadPdf.addEventListener('click', () => elements.pdfInput.click());
        elements.pdfInput.addEventListener('change', loadPdf);
        elements.downloadPdf.addEventListener('click', downloadPdf);
        elements.addWhiteout.addEventListener('click', toggleWhiteoutMode);
        elements.addText.addEventListener('click', toggleTextMode);
        elements.undo.addEventListener('click', undo);
        elements.redo.addEventListener('click', redo);
        elements.clear.addEventListener('click', clearAll);
        elements.prevPage.addEventListener('click', () => changePage(-1));
        elements.nextPage.addEventListener('click', () => changePage(1));

        function updateStatus(message, type = 'info') {
            const icons = { info: 'üìù', success: '‚úÖ', warning: '‚ö†Ô∏è', error: '‚ùå' };
            elements.statusBar.innerHTML = `${icons[type]} <strong>${message}</strong>`;
        }

        async function loadPdf(event) {
            const file = event.target.files[0];
            if (!file || file.type !== 'application/pdf') {
                updateStatus('Please select a valid PDF file', 'error');
                return;
            }
            
            updateStatus('Loading PDF document...', 'info');
            elements.loading.style.display = 'block';
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                elements.pageCount.textContent = pdfDoc.numPages;
                pageNum = 1;
                
                // Enable toolbar buttons
                elements.downloadPdf.disabled = false;
                elements.addWhiteout.disabled = false;
                elements.addText.disabled = false;
                elements.clear.disabled = false;
                
                await renderPage();
                elements.prevPage.disabled = pageNum === 1;
                elements.nextPage.disabled = pageNum === pdfDoc.numPages;
                
                updateStatus(`PDF loaded successfully! ${pdfDoc.numPages} page(s) ready for redaction.`, 'success');
            } catch (error) {
                console.error('PDF loading error:', error);
                updateStatus('Error loading PDF. Please try another file.', 'error');
            } finally {
                elements.loading.style.display = 'none';
            }
        }

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        async function renderPage() {
            if (!pdfDoc) return;
            
            elements.loading.style.display = 'block';
            elements.pdfContainer.innerHTML = '';
            
            try {
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale });
                
                canvas = document.createElement('canvas');
                ctx = canvas.getContext('2d');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                canvas.style.width = viewport.width + 'px';
                canvas.style.height = viewport.height + 'px';
                
                // Store canvas dimensions for coordinate conversion
                canvasWidth = canvas.width;
                canvasHeight = canvas.height;
                
                const container = document.createElement('div');
                container.className = 'canvas-container';
                container.style.width = viewport.width + 'px';
                container.style.height = viewport.height + 'px';
                container.appendChild(canvas);
                elements.pdfContainer.appendChild(container);

                await page.render({ canvasContext: ctx, viewport }).promise;
                setupCanvasEvents(container);
                renderElements();
                
                elements.pageNum.textContent = pageNum;
            } catch (error) {
                console.error('Page rendering error:', error);
                updateStatus('Error rendering page', 'error');
            } finally {
                elements.loading.style.display = 'none';
            }
        }

        function setupCanvasEvents(container) {
            const handleMouseDown = (e) => {
                const pos = getMousePos(e);
                startX = pos.x; startY = pos.y;
                const el = getElementAtPos(startX, startY);
                
                if (el) {
                    selected = el;
                    selected.classList.add('selected');
                    const rect = el.getBoundingClientRect();
                    dragOffsetX = startX - rect.left;
                    dragOffsetY = startY - rect.top;
                    isDragging = true;
                    addToHistory({ type: 'select', id: el.id });
                } else if (isAddingWhiteout) {
                    createWhiteout(startX, startY, 0, 0);
                    isDragging = true;
                } else if (isAddingText) {
                    addText(startX, startY);
                } else if (selected) {
                    selected.classList.remove('selected');
                    selected = null;
                }
            };

            const handleMouseMove = (e) => {
                if (!isDragging || !canvas) return;
                const pos = getMousePos(e);
                currentX = pos.x; currentY = pos.y;
                
                if (selected) {
                    selected.style.left = (currentX - dragOffsetX) + 'px';
                    selected.style.top = (currentY - dragOffsetY) + 'px';
                    updateElementData(selected);
                } else if (isAddingWhiteout) {
                    const whiteout = container.querySelector('.whiteout-area:last-child');
                    if (whiteout) {
                        const width = Math.abs(currentX - startX);
                        const height = Math.abs(currentY - startY);
                        whiteout.style.width = width + 'px';
                        whiteout.style.height = height + 'px';
                        whiteout.style.left = Math.min(startX, currentX) + 'px';
                        whiteout.style.top = Math.min(startY, currentY) + 'px';
                    }
                }
            };

            const handleMouseUp = () => {
                if (isDragging) {
                    if (selected) {
                        addToHistory({ type: 'move', id: selected.id, data: getElementData(selected) });
                    } else if (isAddingWhiteout) {
                        const whiteout = container.querySelector('.whiteout-area:last-child');
                        if (whiteout) {
                            const id = 'whiteout-' + Date.now();
                            whiteout.id = id;
                            whiteouts.push({ 
                                id, 
                                page: pageNum, 
                                x: parseFloat(whiteout.style.left), 
                                y: parseFloat(whiteout.style.top), 
                                width: parseFloat(whiteout.style.width), 
                                height: parseFloat(whiteout.style.height) 
                            });
                            addToHistory({ type: 'add', id, data: whiteouts[whiteouts.length - 1] });
                        }
                        isAddingWhiteout = false;
                        updateModeIndicator();
                    }
                    isDragging = false;
                }
            };

            container.addEventListener('mousedown', handleMouseDown);
            container.addEventListener('mousemove', handleMouseMove);
            container.addEventListener('mouseup', handleMouseUp);
            container.addEventListener('mouseleave', handleMouseUp);
        }

        function getElementAtPos(x, y) {
            const allElements = [...elements.pdfContainer.querySelectorAll('.whiteout-area, .text-element')];
            return allElements.find(el => {
                const rect = el.getBoundingClientRect();
                return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
            });
        }

        function createWhiteout(x, y, width, height) {
            const whiteout = document.createElement('div');
            whiteout.className = 'whiteout-area';
            whiteout.style.left = x + 'px';
            whiteout.style.top = y + 'px';
            whiteout.style.width = width + 'px';
            whiteout.style.height = height + 'px';
            whiteout.title = 'Redaction box - drag to move, click to select';
            elements.pdfContainer.querySelector('.canvas-container').appendChild(whiteout);
        }

        function addText(x, y) {
            const text = prompt('Enter redaction text (e.g., "REDACTED", "CONFIDENTIAL"):', 'REDACTED');
            if (!text || !text.trim()) {
                updateStatus('Text input cancelled', 'warning');
                return;
            }
            
            const textEl = document.createElement('div');
            textEl.className = 'text-element';
            textEl.style.left = x + 'px';
            textEl.style.top = y + 'px';
            textEl.innerHTML = `<div>${text}</div>`;
            textEl.title = 'Redaction text - drag to move, click to select';
            
            const id = 'text-' + Date.now();
            textEl.id = id;
            elements.pdfContainer.querySelector('.canvas-container').appendChild(textEl);
            texts.push({ id, page: pageNum, x: x, y: y, text });
            addToHistory({ type: 'add', id, data: texts[texts.length - 1] });
            
            isAddingText = false;
            updateModeIndicator();
            updateStatus(`Added redaction text: "${text}"`, 'success');
        }

        function updateElementData(el) {
            if (el.classList.contains('whiteout-area')) {
                const index = whiteouts.findIndex(w => w.id === el.id);
                if (index > -1) whiteouts[index] = getElementData(el);
            } else if (el.classList.contains('text-element')) {
                const index = texts.findIndex(t => t.id === el.id);
                if (index > -1) texts[index] = getElementData(el);
            }
        }

        function getElementData(el) {
            if (el.classList.contains('whiteout-area')) {
                return { 
                    id: el.id, 
                    page: pageNum, 
                    x: parseFloat(el.style.left), 
                    y: parseFloat(el.style.top), 
                    width: parseFloat(el.style.width), 
                    height: parseFloat(el.style.height) 
                };
            } else {
                return { 
                    id: el.id, 
                    page: pageNum, 
                    x: parseFloat(el.style.left), 
                    y: parseFloat(el.style.top), 
                    text: el.querySelector('div').textContent 
                };
            }
        }

        function renderElements() {
            // Clear existing elements first
            elements.pdfContainer.querySelectorAll('.whiteout-area, .text-element').forEach(el => el.remove());
            
            // Render whiteouts for current page
            whiteouts.filter(w => w.page === pageNum).forEach(w => {
                createWhiteout(w.x, w.y, w.width, w.height);
            });
            
            // Render texts for current page
            texts.filter(t => t.page === pageNum).forEach(t => {
                const textEl = document.createElement('div');
                textEl.className = 'text-element';
                textEl.id = t.id;
                textEl.style.left = t.x + 'px';
                textEl.style.top = t.y + 'px';
                textEl.innerHTML = `<div>${t.text}</div>`;
                textEl.title = 'Redaction text - drag to move, click to select';
                elements.pdfContainer.querySelector('.canvas-container').appendChild(textEl);
            });
        }

        function toggleWhiteoutMode() {
            isAddingWhiteout = !isAddingWhiteout;
            isAddingText = false;
            elements.addWhiteout.style.background = isAddingWhiteout ? '#e67e22' : '';
            elements.addText.style.background = '';
            updateModeIndicator();
            
            if (isAddingWhiteout) {
                updateStatus('Redaction Box Mode: Click and drag to create redaction boxes', 'warning');
            } else {
                updateStatus('Redaction Box Mode deactivated', 'info');
            }
        }

        function toggleTextMode() {
            isAddingText = !isAddingText;
            isAddingWhiteout = false;
            elements.addText.style.background = isAddingText ? '#27ae60' : '';
            elements.addWhiteout.style.background = '';
            updateModeIndicator();
            
            if (isAddingText) {
                updateStatus('Text Mode: Click to add custom redaction text', 'warning');
            } else {
                updateStatus('Text Mode deactivated', 'info');
            }
        }

        function updateModeIndicator() {
            if (isAddingWhiteout) {
                elements.modeIndicator.textContent = 'Redaction Box Mode';
                elements.modeIndicator.style.display = 'inline-block';
                elements.modeIndicator.style.background = '#e67e22';
            } else if (isAddingText) {
                elements.modeIndicator.textContent = 'Text Mode';
                elements.modeIndicator.style.display = 'inline-block';
                elements.modeIndicator.style.background = '#27ae60';
            } else {
                elements.modeIndicator.style.display = 'none';
            }
        }

        function addToHistory(action) {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            history.push({ ...action, timestamp: Date.now() });
            historyIndex = history.length - 1;
            updateHistoryButtons();
        }

        function updateHistoryButtons() {
            elements.undo.disabled = historyIndex < 0;
            elements.redo.disabled = historyIndex >= history.length - 1;
        }

        function undo() {
            if (historyIndex < 0) return;
            const action = history[historyIndex--];
            
            if (action.type === 'add') {
                if (whiteouts.find(w => w.id === action.id)) {
                    whiteouts = whiteouts.filter(w => w.id !== action.id);
                } else {
                    texts = texts.filter(t => t.id !== action.id);
                }
                document.getElementById(action.id)?.remove();
            } else if (action.type === 'move') {
                const el = document.getElementById(action.id);
                if (el) {
                    el.style.left = action.data.x + 'px';
                    el.style.top = action.data.y + 'px';
                    updateElementData(el);
                }
            } else if (action.type === 'clear') {
                whiteouts = action.data.whiteouts;
                texts = action.data.texts;
                renderElements();
            }
            updateHistoryButtons();
            updateStatus('Undo completed', 'info');
        }

        function redo() {
            if (historyIndex >= history.length - 1) return;
            const action = history[++historyIndex];
            
            if (action.type === 'add') {
                if (action.data.width !== undefined) { // It's a whiteout
                    whiteouts.push(action.data);
                    createWhiteout(action.data.x, action.data.y, action.data.width, action.data.height);
                } else { // It's a text
                    texts.push(action.data);
                    const textEl = document.createElement('div');
                    textEl.className = 'text-element';
                    textEl.id = action.id;
                    textEl.style.left = action.data.x + 'px';
                    textEl.style.top = action.data.y + 'px';
                    textEl.innerHTML = `<div>${action.data.text}</div>`;
                    elements.pdfContainer.querySelector('.canvas-container').appendChild(textEl);
                }
            } else if (action.type === 'move') {
                const el = document.getElementById(action.id);
                if (el) {
                    el.style.left = action.data.x + 'px';
                    el.style.top = action.data.y + 'px';
                    updateElementData(el);
                }
            } else if (action.type === 'clear') {
                whiteouts = [];
                texts = [];
                elements.pdfContainer.querySelectorAll('.whiteout-area, .text-element').forEach(el => el.remove());
            }
            updateHistoryButtons();
            updateStatus('Redo completed', 'info');
        }

        function clearAll() {
            if (whiteouts.length + texts.length === 0) {
                updateStatus('No redaction elements to clear', 'warning');
                return;
            }
            
            if (!confirm('Are you sure you want to clear all redaction boxes and text?')) {
                return;
            }
            
            addToHistory({ type: 'clear', data: { whiteouts: [...whiteouts], texts: [...texts] } });
            whiteouts = [];
            texts = [];
            elements.pdfContainer.querySelectorAll('.whiteout-area, .text-element').forEach(el => el.remove());
            updateStatus('All redaction elements cleared', 'success');
        }

        function changePage(delta) {
            pageNum += delta;
            elements.prevPage.disabled = pageNum === 1;
            elements.nextPage.disabled = pageNum === pdfDoc.numPages;
            renderPage();
            updateStatus(`Now viewing page ${pageNum} of ${pdfDoc.numPages}`, 'info');
        }

        async function downloadPdf() {
            if (!pdfDoc) {
                updateStatus('Please load a PDF first', 'error');
                return;
            }
            
            updateStatus('Generating redacted PDF...', 'info');
            elements.loading.style.display = 'block';
            
            try {
                const pdfDocLib = await PDFLib.PDFDocument.load(await pdfDoc.getData());
                const helveticaFont = await pdfDocLib.embedFont(PDFLib.StandardFonts.HelveticaBold);
                const pages = pdfDocLib.getPages();

                for (let i = 0; i < pages.length; i++) {
                    const page = pages[i];
                    const { width, height } = page.getSize();
                    
                    // Get the original PDF page to match coordinates
                    const originalPage = await pdfDoc.getPage(i + 1);
                    const originalViewport = originalPage.getViewport({ scale: 1 });
                    
                    // Calculate scaling factors
                    const scaleX = width / originalViewport.width;
                    const scaleY = height / originalViewport.height;
                    
                    // Apply whiteouts (redaction boxes) - COMPLETELY BORDERLESS
                    whiteouts.filter(w => w.page === i + 1).forEach(w => {
                        // Convert canvas coordinates to PDF coordinates
                        const pdfX = w.x * (scaleX / scale);
                        const pdfY = height - (w.y * (scaleY / scale) + w.height * (scaleY / scale));
                        const pdfWidth = w.width * (scaleX / scale);
                        const pdfHeight = w.height * (scaleY / scale);
                        
                        // Draw pure white rectangle with NO BORDER
                        page.drawRectangle({
                            x: pdfX,
                            y: pdfY,
                            width: pdfWidth,
                            height: pdfHeight,
                            color: PDFLib.rgb(1, 1, 1), // Pure white
                            borderWidth: 0 // NO BORDER
                        });
                    });
                    
                    // Apply redaction text
                    texts.filter(t => t.page === i + 1).forEach(t => {
                        const pdfX = t.x * (scaleX / scale);
                        const pdfY = height - (t.y * (scaleY / scale) + 16 * (scaleY / scale));
                        
                        page.drawText(t.text, {
                            x: pdfX,
                            y: pdfY,
                            size: 12,
                            font: helveticaFont,
                            color: PDFLib.rgb(0.7, 0.7, 0.7)
                        });
                    });
                }

                const pdfBytes = await pdfDocLib.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `redacted-document-${new Date().getTime()}.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                updateStatus('Redacted PDF downloaded successfully!', 'success');
            } catch (error) {
                console.error('PDF download error:', error);
                updateStatus('Error generating redacted PDF', 'error');
            } finally {
                elements.loading.style.display = 'none';
            }
        }

        // Initialize
        updateStatus('Ready to redact PDF documents', 'info');
    </script>
</body>
</html>